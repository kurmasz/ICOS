###############################################################################
#
# Makefile for ICOS
#
# (C) 2017 Zachary Kurmas
#
# This Makefile requires that i686-elf-gcc, and other necessary 
# toolchain compnents, be in the PATH.
#
# User code goes in usr_src.  The OS image will contain all code in os_src
# and usr_src.  A image with the name my_os.img is assumed to begin at a 
# function named void my_os(void).  Thus, to create a new, custom image
# named my_custom_os.img, simply
#
# (1) Create a function somewhere in usr_src named void my_custom_os(void)
# (2) run make my_custom_os.img
#
# Note:  Because both the .o and .img files are generated by implicit rules,
# make considers the .o files "intermediate" and autmoatically deletes them.
# At the moment, the compiliation process is fast enough that the repeated 
# rebuilds aren't a problem.  If the rebuilding becomes annoying, see this 
# article:  https://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
#
###############################################################################

OS_SRC  = os_src
USR_SRC = usr_src
OS_OBJ = obj/os
BOOT_OBJ = obj/boot
USR_OBJ = obj/usr
elfCC = i686-elf-gcc
CFLAGS = -std=c99 -ffreestanding -Wall -Wextra -I $(OS_SRC)

os_sources = $(wildcard $(OS_SRC)/*.c)      # all *.c files in the os_src dir
usr_sources = $(wildcard $(USR_SRC)/*.c)    # all *.c files in the usr_src dir

# Convert each .c file name into the corresponding .o file name
# (change .c to .o, and change the directory name)
os_objs = $(subst $(OS_SRC), $(OS_OBJ), $(os_sources:.c=.o))
usr_objs = $(subst $(USR_SRC), $(USR_OBJ), $(usr_sources:.c=.o))


all: setup hello_world.img


#
# Make the obj directories, if they don't already exist.
#
$(OS_OBJ):
	mkdir -p $@

$(USR_OBJ):
	mkdir -p $@

$(BOOT_OBJ):
	mkdir -p $@


setup: $(OS_OBJ) $(USR_OBJ) $(BOOT_OBJ)


clean:
	rm $(OS_OBJ)/*.[os] $(USR_OBJ)/*.[os] $(BOOT_OBJ)/*.[os] *.img

#############################################################################
#
# Compile "core" OS
#
#############################################################################

# Headers shouldn't change much.  If they do, then just re-build all
# the .o files
$(OS_OBJ)/%.o: $(OS_SRC)/%.c $(wildcard $(OS_SRC)/*.h) | $(OS_OBJ)
	$(elfCC) $(CFLAGS) -c $< -o $@ -O2
        # generate the assembly file, in case we want to look at it later.
	$(elfCC) $(CFLAGS) -S $< -o $(@:.o=.s) -O2 

# A few OS-supplied routines are better implemented in assembly
$(OS_OBJ)/ic_util_asm.o: $(OS_SRC)/ic_util_asm.s | $(OS_OBJ)
	$(elfCC) $(CFLAGS) -c $< -o $@ -O2

# By naming the file boot.S (instead of boot.s), gcc will run the 
# pre-processor and substitute KERNEL_MAIN with the pattern stem, which 
# is the user-chosen function serving as the kernel entry point.
$(BOOT_OBJ)/%.o: $(OS_SRC)/boot.S
	$(elfCC) $(CFLAGS) -DKERNEL_MAIN=$* -c $< -o $@ -O2


############################################################################
#
# Compile "user provided" parts of OS
#
###########################################################################

# Headers shouldn't change much.  If they do, then just re-build all the 
# .o files
$(USR_OBJ)/%.o: $(USR_SRC)/%.c $(OS_SRC)/*.h $(wildcard $(USR_SRC)/*.h) | $(USR_OBJ)
	$(elfCC) $(CFLAGS) -c $< -o $@ -I $(OS_SRC)
        # generate the assembly file, in case we want to look at it later.
	$(elfCC) $(CFLAGS) -S $< -o $(@:.o=.s) -I $(OS_SRC) 

############################################################################
#
# Bootable image
#
###########################################################################

%.img: $(BOOT_OBJ)/%.o $(os_objs) $(usr_objs) $(OS_OBJ)/ic_util_asm.o | linker.ld
	i686-elf-ld --oformat binary -o $@ $^ -T linker.ld --print-map > /tmp/icos_map.txt

